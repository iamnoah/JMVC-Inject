{"name":"Inject","body":"\r\n[What is dependency injection?](https://github.com/cujojs/wire/wiki/IOC)\r\n\r\n# Functional Dependency Injection for JavaScriptMVC (DoneJS/CanJS)\r\n\r\nIn a traditional dependency injection paradigm, the container manages objects that are connected to each other through the wiring spec. Injection is done by either setting properties or passing values to a constructor function (which typically then sets the properties on the object itself).\r\n\r\nWhile that is a paradigm that works well in object oriented languages, it's more natural in a functional language like JavaScript to inject functions instead.\r\n\r\n**NOTE:** inject-core.js can be used independently of JavaScript MVC. You obviously wont be able to use the Class and Controller based functionality, but named functions and everything else should work.\r\n\r\n## Advantages of injecting functions instead of objects\r\n\r\n * No mutable state - no objects are modified, so it isn't possible for keys names to conflict or for injected values to be changed.\r\n * Late binding - dependencies do not have to be resolved until they are actually needed, so you can defer the creation of expensive objects if desired.\r\n * Rebinding - if the dependency to be injected changes, the next time the function is called, it will receive the new value automatically.\r\n\r\n## Why an injector?\r\n\r\nJMVC Inject is inspired by AMD. The reasons you'd want to inject functions are very similar to the [reasons to use an AMD loader](http://requirejs.org/docs/whyamd.html):\r\n\r\n  * Dependencies are clearly defined.\r\n  * Avoid global variables.\r\n  * Identifiers can be remapped easily, so you can swap out implementations. This is great for testing and makes code more reusable.\r\n  * Encapsulation. For functions, encapsulation means the function code can focus on producing a result instead of worrying about getting all its dependencies in order. This also makes writing [pure functions](http://en.wikipedia.org/wiki/Pure_function) a lot easier.\r\n\r\n## New Features\r\n\r\n * Injecting Controller options - Controllers can have their options set to injected values. Controller instantiation will be deferred.\r\n * Injecting Attributes - Like controllers, Model/Observe style Classes can have their attributes set with values from the injector (but creation will be deferred).\r\n\r\n# Usage\r\n\r\nTo create an injector, call `Inject` with the inject and dependency definitions. The return value of `Inject` (i.e., the injector) is a function.\r\n\r\nInjector definitions are simple objects with a `name` and a `factory` function. The factory function can return any value or it can return a [jQuery.Deferred](http://api.jquery.com/category/deferred-object/) which resolves to the value to inject. *Your factory function is called every time the dependency needs to be injected.*\r\n\r\nIn the examples, we name the injector variable `injector`, but you can call it whatever you want. e.g., `require`, `when`, `myInjector`, etc. The injector is also referred to as the context.\r\n\r\n**NOTE:** these docs are fairly complete, but you can always find working examples in the qunit tests in the test directory.\r\n\r\n## Injecting plain functions\r\n\r\n\tvar injector = Inject({\r\n\t\tname: 'foo',\r\n\t\tfactory: function() {\r\n\t\t\t// your factory function can do anything. if you need to make ajax calls or use\r\n\t\t\t// a web worker or something, just return a jQuery.Deferred\r\n\t\t\treturn 2 * 3;\r\n\t\t}\r\n\t},{\r\n\t\tname: 'bar',\r\n\t\t// this example creates a Deferred manually. $.ajax and\r\n\t\t// all the $.Model finder methods will also return Deferreds\r\n\t\tfactory: function() {\r\n\t\t\tvar def;\r\n\t\t\tdef = $.Deferred();\r\n\t\t\tsetTimeout(function() {\r\n\t\t\t\treturn def.resolve(123);\r\n\t\t\t}, 200);\r\n\t\t\treturn def;\r\n\t\t}\r\n\t});\r\n\r\n\t// pass injector the list of dependencies and the function to inject\r\n\tvar alertFoo = injector('foo',function(foo) {\r\n\t\talert(foo);\r\n\t});\r\n\r\n\talertFoo(); // alerts 6\r\n\r\n\tvar alertBar = injector('bar',function(bar) {\r\n\t\t// notice that bar is the result of the deferred,\r\n\t\t// you never have to deal with a deferred directly\r\n\t\talert(bar);\r\n\t\treturn 'result';\r\n\t});\r\n\r\n\talertBar(); // alerts 123\r\n\r\n\t// your injected function always returns a Deferred\r\n\talertBar().then(function(result) {\r\n\t\talert(result); // alerts 'result'\r\n\t});\r\n\r\nNotice that the names passed to injector have to match the name of the dependency.\r\n\r\nAlso, your injected function will return a `Deferred`, which will resolve to the result.\r\n\r\n## Injector Context / Unbound Functions\r\n\r\nSometimes you need to write a function that will be used in multiple contexts. You can't use the injector directly in this case, as that would create a function that will be injected by just that injector. You need a way to create a function that can use whatever injector context it happens to be called in. This is called an unbound function.\r\n\r\nTo create an unbound function, we use `Inject.require`. Calling a bound function sets the context while that funcion is executing, so any unbound functions called within the stack of a bound function will be injected with the bound function's injector.\r\n\r\nFor `Inject.require` where the function is *called* determines which injector it uses, which is why we say it is unbound.\r\n\r\n\tvar alertFoo = Inject.require('foo',function(foo) {\r\n\t\talert(foo);\r\n\t});\r\n\r\n\tvar injector1 = Inject({\r\n\t\tname: 'foo',\r\n\t\tfactory: function() {\r\n\t\t\treturn 123;\r\n\t\t}\r\n\t});\r\n\tvar injector2 = Inject({\r\n\t\tname: 'foo',\r\n\t\tfactory: function() {\r\n\t\t\treturn 456;\r\n\t\t}\r\n\t});\r\n\r\n\tinjector1(function() {\r\n\t\talertFoo(); // alert 123\r\n\t})();\r\n\r\n\tinjector2(function() {\r\n\t\talertFoo(); // alert 456\r\n\t})();\r\n\r\n\talertFoo();\t// ERROR! No injector is available!\r\n\r\nThere is also `Inject.require.named`, which lets you create named unbound functions just like `injector.named`.\r\n\r\n### Capturing the current context\r\n\r\nCalling a bound function will set the context, but what about functions that need to be called outside of the stack of a bound function?\r\n\r\n\tvar alertFoo = Inject.require('foo',function(foo) {\r\n\t\talert(foo);\r\n\t});\r\n\r\n\tinjector(function() {\r\n\t\tsetTimeout(function() {\r\n\t\t\talertFoo();\t// ERROR! No injector is available!\r\n\t\t},500);\r\n\t})();\r\n\r\nYou can use `Inject.useCurrent` to define a function that will rebind the context to whatever context the function is declared in.\r\n\r\n\tinjector(function() {\r\n\t\tsetTimeout(Inject.useCurrent(function() {\r\n\t\t\talertFoo();\t// OK!\r\n\t\t}),500);\r\n\t})();\r\n\r\nNote that `useCurrent` will throw an exception if there is no current context. If you want to capture the context if there is one, but otherwise proceed as normal, then pass `true` as the second argument.\r\n\r\n### Controller Action Handlers\r\n\r\nControllers action handlers will not generally be called inside a bound function, so they have the same problem as an async function call. Any unbound handler function has to get the injector some other way. `Inject.setupController` will setup the action handlers such that they are bound to the injector context that was active when the controller instance was created:\r\n\r\n\t$.Controller('MyController',{\r\n\t\t// notice this is the static part\r\n\t\tsetup: Inject.setupController\r\n\t\t// OR\r\n\t\tsetup: function() {\r\n\t\t\t// setup will call this._super, so your setup should not\r\n\t\t\tInject.setupController.apply(this,arguments);\r\n\t\t\t// do other setup stuff\r\n\t\t}\r\n\t},{\r\n\t});\r\n\r\n\tvar injector1 = Inject(...);\r\n\tvar injector2 = Inject(...);\r\n\r\n\tinjector1('foo',function() {\r\n\t\t// all action handlers will use injector1\r\n\t\t$('#content1 .myContent').my();\r\n\t});\r\n\tinjector2('foo',function() {\r\n\t\t// all action handlers will use injector2\r\n\t\t$('#content2 .somethingElse').my();\r\n\t});\r\n\r\nUnder the hood, all `setupController` is doing is wrapping each action with\r\n`Inject.useCurrent`.\r\n\r\n\r\n## Return Values & Event Handlers\r\n\r\nBy default, your injector function returns a `$.Deferred`. What if you need a different return value? This is a problem when you try to inject a click handler:\r\n\r\n\t\".someLink click\": Inject.require('foo',function(foo,el,event) {\r\n\t\talert(foo);\r\n\t\treturn false; // oops, this doesn't work, the link is loaded...\r\n\t\t// event.preventDefault() would also not work if any dependency was still loading asynchronously\r\n\t})\r\n\r\nTo fix this, use `andReturn`:\r\n\r\n\t\".someLink click\": Inject.require('foo',function(foo,el,event) {\r\n\t\talert(foo);\r\n\t}).andReturn(false)\r\n\r\n`andReturn` can also take a function. The function will be passed the $.Deferred from the injected function and any addtional arguments passed in (but not the injected arguments):\r\n\r\n\t\".someLink click\": Inject.require('foo',function(foo,el,event) {\r\n\t\talert(foo);\r\n\t}).andReturn(function(deferred,el,event) {\r\n\t\tevent.preventDefault();\r\n\t})\r\n\r\n# Naming\r\n\r\nThis section shows how you can inject functions differently based on their name, the class they belong to, or even using the controller's position in the DOM and controller options.\r\n\r\n## Named Functions\r\n\r\nWhat if you don't know the name of the dependency you want injected or the name varies? You can name your function and use a defintion with an `inject` object to remap its dependencies:\r\n\r\n\tvar injector = Inject({\r\n\t\t// dependency definition\r\n\t\tname: 'bar',\r\n\t\tfactory: function() {\r\n\t\t\treturn 2 * 3;\r\n\t\t}\r\n\t},{\r\n\t\t// inject definition\r\n\t\tname: 'alertFoo',\r\n\t\tinject: {\r\n\t\t\tfoo: 'bar'\r\n\t\t}\r\n\t});\r\n\r\n\tvar alertFoo = injector.named('alertFoo')('foo',function(foo) {\r\n\t\talert(foo);\r\n\t});\r\n\r\n\talertFoo(); // alert 6\r\n\r\n## Injecting Class methods\r\n\r\nIf you're injecting a method on a class defined with $.Class (jQueryMX),\r\nyou can inject any method in that class by using the class name.\r\n\r\n\tvar injector = Inject({\r\n\t\tname: 'foo',\r\n\t\tfactory: function() {\r\n\t\t\treturn {bar:123};\r\n\t\t}\r\n\t}, {\r\n\t\tname: 'TestClass',\r\n\t\tinject: {\r\n\t\t\tthing: 'foo'\r\n\t\t}\r\n\t});\r\n\r\n\t$.Class('TestClass', {}, {\r\n\t\tfoo: injector('thing', function(thing) {\r\n\t\t\talert(thing.bar);\r\n\t\t})\r\n\t});\r\n\r\n\tnew TestClass().foo(); // alerts '123'\r\n\r\nNote: Nothing prevents you from using named functions as methods in your class. The function name will take precedence over the class.\r\n\r\n## Injecting Controller methods\r\n\r\nController methods can be injected just like any other class method, but also offer two additional features:\r\n\r\n 1. Your injector defintion can include a selector, to inject controllers differently depending upon their place in the DOM.\r\n 2. The controller options can be used to define dependencies and as arguments to parameterized factories (see below).\r\n\r\n### Option Substitution\r\n\r\n\tvar injector = Inject({\r\n\t  name: 'foo',\r\n\t  factory: function() {\r\n\t\treturn 123;\r\n\t  }\r\n\t},{\r\n\t  name: 'bar',\r\n\t  factory: function() {\r\n\t\treturn 456;\r\n\t  }\r\n\t});\r\n\r\n\t$.Controller('TestController2', {\r\n\t  defaults: {\r\n\t\tthing: 'foo'\r\n\t  }\r\n\t}, {\r\n\t  init: injector('{thing}', function(foo) {\r\n\t\talert(foo);\r\n\t  })\r\n\t});\r\n\r\n\t$('.selector123').test2(); //alerts 123\r\n\t$('.selector456').test2({thing:'bar'}); //alerts 456\r\n\r\n### Inject by Selector\r\n\r\n\tvar injector = Inject({\r\n\t\tname: 'foo',\r\n\t\tfactory: function() {\r\n\t\t\treturn 123;\r\n\t\t}\r\n\t},{\r\n\t\tname: 'bar',\r\n\t\tfactory: function() {\r\n\t\t\treturn 456;\r\n\t\t}\r\n\t},{\r\n\t\tname: 'TestController2',\r\n\t\tinject: {\r\n\t\t\tthing: 'foo'\r\n\t\t}\r\n\t},{\r\n\t\tname: 'TestController2',\r\n\t\tselector: '.selector456',\r\n\t\tinject: {\r\n\t\t\tthing: 'bar'\r\n\t\t}\r\n\t});\r\n\r\n\t$.Controller('TestController2', {\r\n\t}, {\r\n\t\tinit: injector('thing', function(foo) {\r\n\t\t\talert(foo);\r\n\t\t})\r\n\t});\r\n\r\n\t$('.selector123').test2(); //alerts 123\r\n\t$('.selector456').test2(); //alerts 456\r\n\r\nUsing a selector, we didn't have to pass an option to the 2nd controller to inject it differently.\r\n\r\n### Parameterized Factories\r\n\r\nFactories used by controllers can take options as parameters, to allow for very flexible injection:\r\n\r\n\tvar injector = Inject({\r\n\t\tname: 'foo',\r\n\t\t// a = optionA and b = optionB below\r\n\t\tfactory: function(a,b) {\r\n\t\t\treturn a + b;\r\n\t\t}\r\n\t});\r\n\r\n\t$.Controller('TestController2', {\r\n\t}, {\r\n\t\tinit:injector('foo(optionA,optionB)',function(foo) {\r\n\t\t\talert(foo);\r\n\t\t})\r\n\t});\r\n\r\n\t$('.selector123').test2({\r\n\t\toptionA: 1,\r\n\t\toptionB: 2\r\n\t}); //alerts 3 (1+2)\r\n\r\nParameter names correspond to controller options but should not be contained in `{}`.\r\n\r\n### Injecting controller options\r\n\r\nThe injector can set values on the options object passed to your controller by using the `Inject.setupController` method as your static setup method. This enables templated event binding on injected values (JMVC 3.2+).\r\n\r\nNote that the controller instance itself is not modified, just the initial options hash that is passed in and the injector will *not* override options that are already defined, because they have been passed in to the controller at the point of creation:\r\n\r\n    $.Controller('Foo',{\r\n        // note this is the Static setup method\r\n        setup: Inject.setupController // also fixes controller actions\r\n    },{\r\n        init: function() {\r\n        \t// alerts \"Hello Bob!\"\r\n            alert(this.options.foo + this.options.bar);\r\n        },\r\n        \"{model} foo\": function(model,event) {\r\n        \t// foo changed! do something!\r\n        }\r\n    });\r\n\r\n    Inject({\r\n        name: 'bar',\r\n        factory: function() {\r\n            return 'Hello ';\r\n        }\r\n    },{\r\n        name: 'baz',\r\n        factory: function() {\r\n            return 'World!';\r\n        }\r\n    },{\r\n    \tname: 'someModel',\r\n    \tfactory: // ...\r\n    },{\r\n        name: 'Foo',\r\n        options: {\r\n            foo: 'bar',\r\n            bar: 'baz',\r\n            model: 'someModel'\r\n        }\r\n    })(function() {\r\n        $('#foo').foo({bar: 'Bob!'});\r\n    }).call(this);\r\n\r\n### Injecting Attributes\r\n\r\nSimilarly, classes that take a hash of attribute values as the first argument to their contructor can have injected values set.\r\n\r\nNote that the class instance itself is not modified, just what is passed to the constuctor and the injector will *not* override values that are already defined:\r\n\r\n    $.Observe('Foo',{\r\n        // note this is the Static setup method\r\n        setup: Inject.setup\r\n    },{\r\n        init: function() {\r\n        \t// baz = \"Hello Bob!\"\r\n            this.baz = this.foo + this.bar;\r\n        }\r\n    });\r\n\r\n    Inject({\r\n        name: 'bar',\r\n        factory: function() {\r\n            return 'Hello ';\r\n        }\r\n    },{\r\n        name: 'baz',\r\n        factory: function() {\r\n            return 'World!';\r\n        }\r\n    },{\r\n        name: 'Foo',\r\n        attrs: {\r\n            foo: 'bar',\r\n            bar: 'baz'\r\n        }\r\n    })(function() {\r\n        new Foo({bar:'Bob!'}).done(function(foo) {\r\n            alert(foo.baz);\r\n        });\r\n    }).call(this);\r\n\r\n# Misc\r\n\r\n## Caching\r\n\r\nYour factory function is called every time a dependency needs to be injected. If you are injecting a resource that needs to be loaded, that wont be very efficient. You'll want to cache the dependency after it is first loaded, to avoid making lots of expensive calls.\r\n\r\n`Inject.cache` creates a helper function that will do that for you:\r\n\r\n\tvar number = 1;\r\n\tvar singleton = Inject.cache();\r\n\tvar injector = Inject({\r\n\t\tname: 'foo',\r\n\t\tfactory: singleton('foo',function() {\r\n\t\t\treturn number++;\r\n\t\t})\r\n\t});\r\n\talertFoo(); // alerts 1\r\n\talertFoo(); // also alerts 1\r\n\r\nWithout the cache, the 2nd call of `alertFoo()` would have alerted 2.\r\n\r\nThe first argument to the cache function is the unique key for the cached value. You can use the key to clear the cached value at a later time so that the factory will be called again:\r\n\r\n\tsingleton.clear('foo');\r\n\talertFoo(); // alerts 2\r\n\talertFoo(); // also alerts 2\r\n\r\nSince your cache key will often also be the name of the dependency, the cache function has a helper that will produce the whole definition for you:\r\n\r\n\tvar injector = Inject(\r\n\t\tsingleton.def('foo',function() {\r\n\t\t\treturn number++;\r\n\t\t})\r\n\t);\r\n\r\n## Eager loading\r\n\r\nIf your definition includs `eager: true`, your factory will be called immediately after the injector is created. This is useful for preloading dependencies.\r\n\r\n\tvar number = 1;\r\n\tvar singleton = Inject.cache();\r\n\tvar injector = Inject({\r\n\t\tname: 'foo',\r\n\t\teager: true,\r\n\t\tfactory: singleton(function() {\r\n\t\t\treturn number++;\r\n\t\t})\r\n\t});\r\n\t// number === 2\r\n\talertFoo(); // alerts 1, since 1 was cached\r\n\r\nNote that you can use the `def` shortcut for eager dependencies, just pass `true` as the 3rd arugment.\r\n\r\n## Destroying the injector\r\n\r\nThe injector has a destroy method:\r\n\r\n    injector.destroy();\r\n\r\nOnce it is called, any function that was bound to that injector will become a noop, and functions that have been called and are waiting for dependencies to resolve will also never execute.\r\n\r\nThis is useful when you know you are done with an injector and want to cleanup any functions that may have been bound to it.\r\n\r\n","tagline":"A functional dependency injector for JavaScript MVC.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}